<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <assembly alias="System.Windows.Forms" name="System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" />
  <data name="checkmark-16" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>..\Resources\checkmark-16.png;System.Drawing.Bitmap, System.Drawing, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a</value>
  </data>
  <data name="Help" xml:space="preserve">
    <value>Use: DSinject [-base folder_path]
              [-name short_name] [-longname name_line_1 name_line_2]
              [-in folder_path] [-rom file_path]
              [-icon file_path] [-tv file_path] [-drc file_path]
              [-out folder_path] [not-encrypt]
 Or: DSinject help
 Or: DSinject load-key common_key
 Or: DSinject load-base folder_path
 Or: DSinject create-image [-frame file_path] [-title file_path]
              [-name short_name|-longname name_line_1 name_line_2]
			  [-r value] [-out folder_path]
 Or: DSinject create-icon [-frame file_path] [-title file_path]
              [-out folder_path]
 Or: DSinject pack|unpack -in folder_path [-out folder_path]

Options:

 help
    Show this help message.

 load-key common_key
    The Wii U Common Key is required to pack and unpack NUS CONTENT.
 load-base folder_path
    Path to the NDS VC game that will be copied internally "base" where the ROM will be injected.

 create-image
    Indicates that must create an image for the boot screen.
 create-icon
    Indicates that must create an icon to represent a game.

 pack
    Indicates that the NUS CONTENT input will be encrypted.
 unpack
    Indicates that the NUS CONTENT input will be decrypted.

 -base folder_path
    Path to the NDS VC game where the ROM will be injected.
    The process does not modify the NDS VC game since it creates an internal copy of the game "base", if not specified, the previous loaded base will be used.
 -name short_name
    A short game name to show.
    If not specified, the name inside ROM will be used.
    If the create-image option is present, it indicates the name of a single line that will be placed on the frame image.
 -longname name_line_1 name_line_2
    A long game name to show can be two lines.
    If not specified, the name inside ROM will be used.
    If the create-image option is present, it indicates the name of two lines that will be placed on the frame image.
 -in folder_path
    Path where the "rom.nds", "icon.png", "tv.png" and "drc.png" files are taken.
    If the pack|unpack option is present it indicates the path to the NUS CONTENT.
 -rom file_path
    Path to the NDS game ROM.
    If not specified, the "rom.nds" file will be searched in the "-in" folder.
 -icon file_path
    Path to an image file to use as icon (*.png, *.jpg or *.bmp).
    If not specified, the "icon.png" file will be searched in the "-in" folder, if not found a default image will be used.
 -tv file_path
    Path to an image file to use as boot tv (*.png, *.jpg or *.bmp).
    If not specified, the "tv.png" file will be searched in the "-in" folder, if not found a default image will be used.
 -drc file_path
    Path to an image file to use as boot drc (*.png, *.jpg or *.bmp).
    If not specified, the "drc.png" file will be searched in the "-in" folder, if not found the boot tv image will be used.
 -out folder_path
    Path where the result will be put.
    If not specified, the root folder of DSInject will be used.
 not-encrypt
    Indicates that the result should not be encrypted, by default is encrypted.

 -title file_path
    Path to the image of the title screen, which will be placed on the background by default. If not specified, a black box will be placed.
 -frame file_path
    Path to the frame image, which will be placed on the title screen.
    If not specified, the background will be seen by default.
 -r value
    A value greater than or equal to 2004, that represents the launch year of the game, will be placed on the frame image.

Note:
    If the paths or names contain spaces put them in quotes.</value>
  </data>
  <data name="x-mark-16" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>..\Resources\x-mark-16.png;System.Drawing.Bitmap, System.Drawing, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a</value>
  </data>
</root>